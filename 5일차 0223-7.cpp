#include<iostream>
using namespace std;
void main() {

	// [기억영역, 저장공간]
	/*
	 stack vs heap
	 data
	
	 지역변수, 매개변수
	 -> 프로그램이 실행되기 이전에 크기가 결정 -> 배열 -> 정적이다.
	 
	 -----------------------------------------------------------
	 
	 프로그래머의 영역, 프로그래머가 할당하여 이용
	 동적할당이 이루어지는 공간 -> 프로그램 실행된 이후에 크기가 결정
	 malloc(),free() ->heap영역에 저장하겠다 -> 동적이다.

	 malloc(),free()
	 함수 -> 라이브러리
	 수행속도가 다소 느림
	 할당받을 공간의 크기를 함수인자로 줘야함 -> sizeof()연산자 사용
	 리턴타입은 void* -> 리턴타입이 자동설정xx -> 형변환(캐스팅)해줘야함
	 초기화가 불가능 ->초기화를 따로 해줘야함 -> calloc()(0으로 초기화 가능하게 해주는 함수)
	 저장공간크기를 다루는데에 용이 -> realloc()(크기변경하여 재할당)

	 vs

	 new ,delete
	 연산자
	 수행속도가 보다 빠름
	 할당받을 공간의 크기를 자동지정
	 해당 타입의 포인터를 자동리턴
	 초기화가 가능 -> 생성자(초기값설정)
	 크기할당 -> 값 복사 -> 원래공간에 대한 메모리를 해제 // Point p[3] 이거 할때 쓰던거 다른생성자 이용하면 생기던거


	*/

	/*int* arr = (int*)malloc(10 * sizeof(int));
	for (int i = 0; i < 10; i++) {
		arr[i] = i + 1;
		cout << arr[i] << " ";
	}
	--> 이걸 new로 해보면
	*/
	
	int i=int(10); // --> int 생성자를 통해 만듬
	// -> 그래서 값이 0으로 초기화됨 값을 넣고 싶으면 () 안에 넣으면 값이 들어감
	cout << "i: " << i << endl;

	int* i1 = new int(10); //-> 주소가 나오기 때문에 포인터로 받아줘야 한다.
	int* i2 = (int*)malloc(sizeof(int));
		// 둘다 heap 영역에 있기 때문에 
		// 공간을 할당 받으면 자동으로 주소가 나오는데 그 주소를 기억해야 하기 때문에 * 필요
	cout << *i1 << " " << *i2 << endl;
	// i2 는 malloc이라 초기화가 안돼는데 new는 초기화 까지 가능해서
	// malloc는 쓰레기값 들어가고 new 는 10이 들어감

	int N = 3;
	int* arr = new int[N];
	for (int i = 0; i < N; i++) {
		//arr[i] = int(i + 1); //이것도 되고 밑에것도 되고 상관없음
		arr[i] = i + 1;
		cout << arr[i] << " ";
	}
	cout << endl;

	int* arr2 = new int[3];
	for (int i = 0; i < 3; i++) {
		arr2[i] = (i + 1) * 10;
		cout << arr2[i] << " ";
	}
	cout << endl;
}